包地址：http://golang.org/pkg/bytes/
Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the strings package.
bytes 包实现了操作byte slices的方法。和它类似的是strings包

func Compare(a, b []byte) int
  Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a==b, -1 if a < b, and +1 if a > b. A nil argument is equivalent to an empty slice.
  对比两个byte slices 返回整型对比结果。如果a==b返回0,如果a<b返回-1,如果a>b返回+1。nil参数等价于空的slice

func Contains(b, subslice []byte) bool
  Contains returns whether subslice is within b.
  Contains 返回subslice（切片）是否存在b
  
func Count(s, sep []byte) int
  Count counts the number of non-overlapping instances of sep in s.
  Count 统计s里不重复的sep的数量
  
func Equal(a, b []byte) bool
  Equal returns a boolean reporting whether a == b. A nil argument is equivalent to an empty slice.
  Equal返回a是否等b的布尔类型。nil参数相当于空slice

func EqualFold(s, t []byte) bool
  EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under Unicode case-folding.
  EqualFold t 从 s 截断看是不是对等的

func Fields(s []byte) [][]byte
  Fields splits the slice s around each instance of one or more consecutive white space characters, returning a slice of subslices of s or an empty list if s contains only white space.
  Fields 通过一个或多个连续的空格符 分割slice s，返回s的子切片，如果s只有空格符那返回空列
  
func FieldsFunc(s []byte, f func(rune) bool) [][]byte
  FieldsFunc interprets s as a sequence of UTF-8-encoded Unicode code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If no code points in s satisfy f(c), an empty slice is returned.
  FieldsFunc 根据utf编码的代码点排序s。它根据函数f 分割s，返回多个s的子切片。如果f里没有s的代码点，返回一个空slice

func HasPrefix(s, prefix []byte) bool
  HasPrefix tests whether the byte slice s begins with prefix。.
  HasPrefix 检查s的开头是不是prefix

func HasSuffix(s, suffix []byte) bool
  HasSuffix tests whether the byte slice s ends with suffix.
  HasSuffix 检查s是不是以suffix结束的

func Index(s, sep []byte) int
  Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.
  Index返回sep在s里的索引，如果sep没有在s里返回-1

func IndexAny(s []byte, chars string) int
  IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.
  IndexAny S是一个utf8 序列的代码点。返回在s里第一个遇到的chars的代码点的索引。如果chars是空的或者没有代码点返回-1

func IndexByte(s []byte, c byte) int
  IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.
  返回s里遇到的第一个c的索引，如果c没有在s里，返回-1

func IndexFunc(s []byte, f func(r rune) bool) int
  IndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do.
  IndexFunc s一个UTF8序列的代码点。返回f中第一个遇到的Unicode 代码点的字节的索引。如果没有做返回-1

func IndexRune(s []byte, r rune) int
  IndexRune interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s.
  IndexRune s一个UTF8序列的代码点。返回s中第一个在rune里遇到字节的索引。如果rune没有出现在s里 返回-1

func Join(s [][]byte, sep []byte) []byte
  Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice.
  Join 连接s里的元素形成一个新的byte slice。在结果的slice中分隔符sep在两个元素之间。

func LastIndex(s, sep []byte) int
  LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.
  LastIndex 返回在s中出现sep的最后的索引，如果sep没有在s里返回-1

func LastIndexAny(s []byte, chars string) int
  LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common.
  LastIndexAny S是一个utf8 序列的代码点。返回s里最后遇到的chars的代码点的索引。如果chars是空的或者没有代码点返回-1

func LastIndexFunc(s []byte, f func(r rune) bool) int
  LastIndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do.
  LastIndexFunc s一个UTF8序列的代码点。返回f中最后遇到的Unicode 代码点的字节的索引。如果没有做返回-1

func Map(mapping func(r rune) rune, s []byte) []byte
  Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the string with no replacement. The characters in s and the output are interpreted as UTF-8-encoded Unicode code points.
  Map 返回s 依照mapping函数修改 的拷贝。如果mapping返回负值，字符从string里删除。s里的字符和输出的编码都是utf8代码点。
  
func Repeat(b []byte, count int) []byte
  Repeat returns a new byte slice consisting of count copies of b.
  Repeat 返回一个从b拷贝的count长度的新byte slice 

func Replace(s, old, new []byte, n int) []byte
  Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If n < 0, there is no limit on the number of replacements.
  Replace 返回s被old替代n次的拷贝slice。如果n<0替换的数量就没有限制。

func Runes(s []byte) []rune
  Runes returns a slice of runes (Unicode code points) equivalent to s.
  Runes 返回一个runes slice（Unicode代码点（相当于Unicode格式））等价于 s
  
func Split(s, sep []byte) [][]byte
  Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1.
  Split s根据sep分割子切片，返回子切片的分隔符。如果sep是空的，splits 按每个UTF8序列分割。等价于SplitN cout -1

func SplitAfter(s, sep []byte) [][]byte
  SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1.
  SplitAfter s根据sep分割，返回子切片的切片。如果sep是空的，SplitAfter 按每个UTF8序列分割，等价于SplitAfterN  count -1
  
func SplitAfterN(s, sep []byte, n int) [][]byte
  SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return:
  s根据sep分割，返回子切片的切片。如果sep是空的SplitAfterN按每个UTF8序列分割,n决定返回子切片的数量：
  n > 0: at most n subslices; the last subslice will be the unsplit remainder.
    最后一个切片是剩余的未切片的子切片
  n == 0: the result is nil (zero subslices)
  n < 0: all subslices

func SplitN(s, sep []byte, n int) [][]byte
  SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return:
  s根据sep分割子切片，返回切片之间的分隔符的切片。如果sep是空的，SplitN 按每个utf8序列分割，n决定返回子切片的数量：
  n > 0: at most n subslices; the last subslice will be the unsplit remainder.
  n == 0: the result is nil (zero subslices)
  n < 0: all subslices

func Title(s []byte) []byte
  Title returns a copy of s with all Unicode letters that begin words mapped to their title case.
  返回所有的Unicode字母单词 大写拷贝s。
  BUG: The rule Title uses for word boundaries does not handle Unicode punctuation properly.
  BUG：title规则不处理边界单词的编码

func ToLower(s []byte) []byte
  ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case.
  返回所有Unicode字母的小写拷贝 s

func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte
  ToLowerSpecial returns a copy of the byte slice s with all Unicode letters mapped to their lower case, giving priority to the special casing rules.
  返回所有Unicode字母的小写拷贝s，优先考虑特殊规则

func ToTitle(s []byte) []byte
  ToTitle returns a copy of the byte slice s with all Unicode letters mapped to their title case.
  返回所有的Unicode字母单词 大写拷贝s。

func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte
  ToTitleSpecial returns a copy of the byte slice s with all Unicode letters mapped to their title case, giving priority to the special casing rules.
  返回所有的Unicode字母单词 大写拷贝s。优先考虑特殊规则

func ToUpper(s []byte) []byte
  ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case.
  所有的Unicode字母单词 大写拷贝s。
  
func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte
  ToUpperSpecial returns a copy of the byte slice s with all Unicode letters mapped to their upper case, giving priority to the special casing rules.
  所有的Unicode字母单词 大写拷贝s。优先考虑特殊规则

func Trim(s []byte, cutset string) []byte
  Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded Unicode code points contained in cutset.
  Trim 返回 s 根据 cutset 去除头部和尾部的UTF8编码切片。（相当于其他语言的trim ，就是能设置要trim的字符）

func TrimFunc(s []byte, f func(r rune) bool) []byte
  TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded Unicode code points c that satisfy f(c).
  TrimFunc 返回 根据函数f  去除头部和尾部的UTF8编码切片

func TrimLeft(s []byte, cutset string) []byte
  TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded Unicode code points contained in cutset.
  TrimLeft 返回 s 根据 cutset 去除头部的UTF8编码切片

func TrimLeftFunc(s []byte, f func(r rune) bool) []byte
  TrimLeftFunc returns a subslice of s by slicing off all leading UTF-8-encoded Unicode code points c that satisfy f(c).
  TrimFunc 返回 根据函数f  去除头部的UTF8编码切片

func TrimPrefix(s, prefix []byte) []byte
  TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged.
  返回去掉prefix的开始的字符串s，如果s不是以prefix开始的，S没有被改变

func TrimRight(s []byte, cutset string) []byte
  TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded Unicode code points that are contained in cutset.
  返回 s 根据 cutset 去除尾部的UTF8编码切片

func TrimRightFunc(s []byte, f func(r rune) bool) []byte
  TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8 encoded Unicode code points c that satisfy f(c).
  返回 根据函数f  去除尾部的UTF8编码切片

func TrimSpace(s []byte) []byte
  TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode.
  返回根据空格去掉头部和尾部的UTF8编码切片

func TrimSuffix(s, suffix []byte) []byte
  TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged.
  返回去掉prefix的结束的字符串s，如果s不是以prefix结束的，S没有被改变

type Buffer
  A Buffer is a variable-sized buffer of bytes with Read and Write methods. The zero value for Buffer is an empty buffer ready to use.
  Buffer 是一个可变大小 可读写缓冲区的方法。缓冲区的0值是一个空的准备被使用的缓冲区
  
  func NewBuffer(buf []byte) *Buffer
    NewBuffer creates and initializes a new Buffer using buf as its initial contents. It is intended to prepare a Buffer to read existing data. It can also be used to size the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero.
    创建和初始化一个新的Buffer使用buf初始化内容。它的目的是准备读取存在的数据。它也可以用来写入内部的缓冲区大小。为了做到这点，buf应该有足够的大小，但是长度为0
    In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer.
    大部分情况下，new(Buffer) （或者只是声明一个缓冲变量）足够初始化缓冲区。
    
  func NewBufferString(s string) *Buffer
    NewBufferString creates and initializes a new Buffer using string s as its initial contents. It is intended to prepare a buffer to read an existing string.
    创建和初始化一个新的Buffer使用s初始化内容它的目的是准备读取存在的数据。
    In most cases, new(Buffer) (or just declaring a Buffer variable) is sufficient to initialize a Buffer.
    大部分情况下，new(Buffer) （或者只是声明一个缓冲变量）足够初始化缓冲区。
  
  func (b *Buffer) Bytes() []byte
    Bytes returns a slice of the contents of the unread portion of the buffer; len(b.Bytes()) == b.Len(). If the caller changes the contents of the returned slice, the contents of the buffer will change provided there are no intervening method calls on the Buffer.
    返回未读取内容部分的缓冲区slice。 len(b.Bytes()) == b.Len()。如果调用者改变了返回的slice内容，若没有其他调用改变缓冲区，缓冲区的内容也会跟着改变，
  
  func (b *Buffer) Grow(n int)
    Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with ErrTooLarge.
    增加缓冲区的容量，如果需要，保证空间的n字节。增长之后，在没有分配其他的时候至少能写入n个字节。如果n是负数，Grow 将会panic。如果缓冲区不能增加，将会panic ErrTooLarge
  
  func (b *Buffer) Len() int
    Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()).
    返回 缓冲区内未读的部分。
    
  func (b *Buffer) Next(n int) []byte
    Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by Read. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method.
    从缓冲区里返回下n个字节的切片，如果返回的字节是读取的，推进缓冲区。如果缓冲区的字节比n少，返回所有的缓冲区内容。切片只到下一次调用读或写有效。
  
  func (b *Buffer) Read(p []byte) (n int, err error)
    Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is io.EOF (unless len(p) is zero); otherwise it is nil.
    从缓冲区里读取p长度的字节，直到缓冲区为空。返回值是读取的缓冲区字节的数量。如果缓冲区没有数据返回，错误 要嘛是io.EOF 要嘛是nil
  
  func (b *Buffer) ReadByte() (c byte, err error)
    ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error io.EOF.
    读取 和返回缓冲区的下一个字节。如果字节无效，会返回错误 io.EOF。
  
  func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
    ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim.
    读取输入直到第一次遇到delim，返回切片数据包含分隔符。如果在遇到分隔符之前遇到错误，返回遇到错误之前读取的错误和错误本身（经常是io.EOF）。当且仅当不以delim结束时返回nil
  
  func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)
    ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with ErrTooLarge.
    从r中读取数据直到 EOF 然后把数据加入缓冲区，缓冲区需要增加。返回值n时读取的字节数。除了 io.EOF 之外的错误都不会在读取之间返回。如果缓冲区变得太大，ReadFrom 会引发panic  ErrTooLarge
  
  func (b *Buffer) ReadRune() (r rune, size int, err error)
    ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1.
    从缓冲区里返回utf8代码点。如果字节无效，将会返回错误 io.EOF。如果字节不是utf编码，会消耗一个字节 返回 U+FFFD, 1
  
  func (b *Buffer) ReadString(delim byte) (line string, err error)
  ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim.
  
  
  func (b *Buffer) Reset()
  func (b *Buffer) String() string
  func (b *Buffer) Truncate(n int)
  func (b *Buffer) UnreadByte() error
  func (b *Buffer) UnreadRune() error
  func (b *Buffer) Write(p []byte) (n int, err error)
  func (b *Buffer) WriteByte(c byte) error
  func (b *Buffer) WriteRune(r rune) (n int, err error)
  func (b *Buffer) WriteString(s string) (n int, err error)
  func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)
type Reader
    func NewReader(b []byte) *Reader
    func (r *Reader) Len() int
    func (r *Reader) Read(b []byte) (n int, err error)
    func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
    func (r *Reader) ReadByte() (b byte, err error)
    func (r *Reader) ReadRune() (ch rune, size int, err error)
    func (r *Reader) Seek(offset int64, whence int) (int64, error)
    func (r *Reader) UnreadByte() error
    func (r *Reader) UnreadRune() error
    func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
