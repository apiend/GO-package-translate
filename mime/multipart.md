Package multipart

Overview ▾

Package multipart implements MIME multipart parsing, as defined in RFC 2046.
The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers.
multipart包实现在 RFC 2046定义的 MIME 多重解析,
这个实现通过流行的浏览器  满足 HTTP 和 产生多重机构


type File

type File interface {
        io.Reader
        io.ReaderAt
        io.Seeker
        io.Closer
}
File is an interface to access the file part of a multipart message. 
Its contents may be either stored in memory or on disk. If stored on disk, the File's underlying concrete type will be an *os.File.
File 是访问文件 多重信息部分的接口.
它的内容可能存储在内存或磁盘里.如果存储在磁盘里,File的底层 具体类型将会是 *os.File.



type FileHeader

type FileHeader struct {
        Filename string
        Header   textproto.MIMEHeader
        // contains filtered or unexported fields
}
A FileHeader describes a file part of a multipart request.
一个FileHeader描述 一个 文件的多重请求部分



func (*FileHeader) Open

func (fh *FileHeader) Open() (File, error)
Open opens and returns the FileHeader's associated File.
Open 打开和返回 FileHeader 关联的File.



type Form

type Form struct {
        Value map[string][]string
        File  map[string][]*FileHeader
}
Form is a parsed multipart form. 
Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. 
Its Value parts are stored as strings. Both are keyed by field name.
Form是一个解析多重形式.
它的File部分 存储在内存或磁盘里,并且 通过 *FileHeader的 Open方法访问.
它的Value部分 存储成字符串.两者都是由字段名键控。



func (*Form) RemoveAll

func (f *Form) RemoveAll() error
RemoveAll removes any temporary files associated with a Form.
RemoveAll删除任何 和 一个Form有关的临时文件


type Part

type Part struct {
        // The headers of the body, if any, with the keys canonicalized
        // in the same fashion that the Go http.Request headers are.
        // For example, "foo-bar" changes case to "Foo-Bar"
        //
        // As a special case, if the "Content-Transfer-Encoding" header
        // has a value of "quoted-printable", that header is instead
        // hidden from this map and the body is transparently decoded
        // during Read calls.
         
         //和 keys 在相同的的方法 规范化 那就是 GO http.Request 的头.
        //例如 "foo-bar" 变成"Foo-Bar"
        
        //一个特殊的情况,如果 "Content-Transfer-Encoding"头 有一个值是 "quoted-printable",
        //那个头 从这个map中替代 隐藏并且 body在Read调用期间 透明解析.
        
        Header textproto.MIMEHeader
        // contains filtered or unexported fields
}
A Part represents a single part in a multipart body.
一个Part 表示 多重body 中的单个部分


func (*Part) Close

func (p *Part) Close() error



func (*Part) FileName

func (p *Part) FileName() string
FileName returns the filename parameter of the Part's Content-Disposition header.
FileName返回Part的 Content-Disposition 头 文件参数



func (*Part) FormName

func (p *Part) FormName() string
FormName returns the name parameter if p has a Content-Disposition of type "form-data". Otherwise it returns the empty string.
如果p有一个Content-Disposition  类型 "form-data",FormName返回参数名字.否则返回空字符串



func (*Part) Read

func (p *Part) Read(d []byte) (n int, err error)
Read reads the body of a part, after its headers and before the next part (if any) begins.
Read 读取 主体的一部分,在它的 头后面  和 下一个 部分 开始之间.


type Reader

type Reader struct {
        // contains filtered or unexported fields
}
Reader is an iterator over parts in a MIME multipart body. 
Reader's underlying parser consumes its input as needed. Seeking isn't supported.
Reader 迭代 MIME多重body部分.
Reader的底层解析器 消耗需要的输入.不支持查找。


func NewReader

func NewReader(r io.Reader, boundary string) *Reader
NewReader creates a new multipart Reader reading from r using the given MIME boundary.
The boundary is usually obtained from the "boundary" parameter of the message's "Content-Type" header. 
Use mime.ParseMediaType to parse such headers.
NewReader 使用给定的MIME boundary 读取r 创建一个新的 多重 Reader 
boundary通常从 "boundary"  参数 的信息 "Content-Type"头 中获得.


Example:
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"mime"
	"mime/multipart"
	"net/mail"
	"strings"
)

func main() {
	msg := &mail.Message{
		Header: map[string][]string{
			"Content-Type": []string{"multipart/mixed; boundary=foo"},
		},
		Body: strings.NewReader(
			"--foo\r\nFoo: one\r\n\r\nA section\r\n" +
				"--foo\r\nFoo: two\r\n\r\nAnd another\r\n" +
				"--foo--\r\n"),
	}
	mediaType, params, err := mime.ParseMediaType(msg.Header.Get("Content-Type"))
	if err != nil {
		log.Fatal(err)
	}
	if strings.HasPrefix(mediaType, "multipart/") {
		mr := multipart.NewReader(msg.Body, params["boundary"])
		for {
			p, err := mr.NextPart()
			if err == io.EOF {
				return
			}
			if err != nil {
				log.Fatal(err)
			}
			slurp, err := ioutil.ReadAll(p)
			if err != nil {
				log.Fatal(err)
			}
			fmt.Printf("Part %q: %q\n", p.Header.Get("Foo"), slurp)
		}
	}

}



func (*Reader) NextPart

func (r *Reader) NextPart() (*Part, error)
NextPart returns the next part in the multipart or an error.
When there are no more parts, the error io.EOF is returned.
NextPart返回多重中的下一个部分或一个错误.
当没有更多的part ,返回  io.EOF错误.



func (*Reader) ReadForm

func (r *Reader) ReadForm(maxMemory int64) (f *Form, err error)
ReadForm parses an entire multipart message whose parts have a Content-Disposition of "form-data". 
It stores up to maxMemory bytes of the file parts in memory and the remainder on disk in temporary files.
ReadForm 解析 有Content-Disposition "form-data" 的  整个多重信息 
它最多可存储maxMemory 字节的文件parts 到内存 和在磁盘上的剩余部分临时文件。



type Writer

type Writer struct {
        // contains filtered or unexported fields
}
A Writer generates multipart messages.
一个Writer 生成多重信息



func NewWriter

func NewWriter(w io.Writer) *Writer
NewWriter returns a new multipart Writer with a random boundary, writing to w.
NewWriter 以一个随机的边界 返回一个新的 多重 Writer , 写到w.



func (*Writer) Boundary

func (w *Writer) Boundary() string
Boundary returns the Writer's boundary.
Boundary 返回 Writer的边界



func (*Writer) Close

func (w *Writer) Close() error
Close finishes the multipart message and writes the trailing boundary end line to the output.
Close 结束多重信息 并且  写 尾随边界的最后一行到输出.



func (*Writer) CreateFormField

func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)
CreateFormField calls CreatePart with a header using the given field name.
CreateFormField 一个header使用给定的字段名  调用 CreatePart


func (*Writer) CreateFormFile

func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)
CreateFormFile is a convenience wrapper around CreatePart. 
It creates a new form-data header with the provided field name and file name.
CreateFormFile 大概是CreatePart方便封装.
它用提供的字段名和文件名创建一个新的form-data头.



func (*Writer) CreatePart

func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)
CreatePart creates a new multipart section with the provided header. 
The body of the part should be written to the returned Writer. 
After calling CreatePart, any previous part may no longer be written to.
CreatePart 以提供的头创建一个新的 multipart 章节
part的主体应该写到返回的Writer.
调用CreatePart之后,任何以前的part 可能不会再写入.



func (*Writer) FormDataContentType

func (w *Writer) FormDataContentType() string
FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary.
FormDataContentType 根据Writer的 Boundary返回 一个HTTP multipart/form-data的Content-Type



func (*Writer) SetBoundary

func (w *Writer) SetBoundary(boundary string) error
SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value.
SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be 1-69 bytes long.
SetBoundary 覆盖Writer的默认 随机生成的边界 分离一个明确的值。
SetBoundary 必须在任何part创建之前调用, 可能只包含某些 ASCII字符, 并且 必须是 1-69字节长度.



func (*Writer) WriteField

func (w *Writer) WriteField(fieldname, value string) error
WriteField calls CreateFormField and then writes the given value.
WriteField调用CreateFormField 然后写入给定的值.











