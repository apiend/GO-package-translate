Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.
bufio包实现缓冲I/O。包装io.Reader或io.Writer对象，创建实现其他接口但提供缓冲和文本的IO

func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)
  ScanBytes is a split function for a Scanner that returns each byte as a token.
  ScanBytes是一个分割输入函数，通过token参数返回每个字符

func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)
  ScanLines is a split function for a Scanner that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\r?\n`. The last non-empty line of input will be returned even if it has no newline.
  ScanLines是一个分割函数。返回每一行文本，消除任何结束标记。返回的行有可能是空的，行尾标记是可选项，强制性的接在返回的行尾。在正则表达式里他\r\n，没有换行最后一个非空行输入将被返回
  
func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)
  ScanRunes is a split function for a Scanner that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = "\xef\xbf\xbd". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors.
  ScanRunes返回utf8的整型（token）。返回的顺序是输入字符串的顺序，那就是说错误的utf8编码转译成U+FFFD = "\xef\xbf\xbd". 因为输入接口，可能让正确的编码替换掉错误的

func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)
  ScanWords is a split function for a Scanner that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace.
  根据空白切割单词，会把空白清除掉。不会返回空字符串。由unicode.IsSpace定义空白


type ReadWriter
  type ReadWriter struct {
        *Reader
        *Writer
  }
  ReadWriter stores pointers to a Reader and a Writer. It implements io.ReadWriter.
  存储指针是一个读和一个写指针，由io.ReadWriter实现
  
func NewReadWriter(r *Reader, w *Writer) *ReadWriter
  NewReadWriter allocates a new ReadWriter that dispatches to r and w.
  分配一个新的ReadWriter
  
type Reader
  type Reader struct {
        // contains filtered or unexported fields
  }
    Reader implements buffering for an io.Reader object.
    使用io.Reader对象实现缓冲
    
  func NewReader(rd io.Reader) *Reader
    NewReader returns a new Reader whose buffer has the default size.
    返回一个新的Reader指针，有默认缓冲区大小
    
  func NewReaderSize(rd io.Reader, size int) *Reader
    NewReaderSize returns a new Reader whose buffer has at least the specified size. If the argument io.Reader is already a Reader with large enough size, it returns the underlying Reader.
    返回一个新的有指定大小的Reader指针，如果 io.Reader的缓冲区够大，返回指针
  
  func (b *Reader) Buffered() int
    Buffered returns the number of bytes that can be read from the current buffer.
    返回当前可读的缓冲区长度
  
  func (b *Reader) Peek(n int) ([]byte, error)
    Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is ErrBufferFull if n is larger than b's buffer size.
    没有超过缓冲区的时候，返回n字节长度。字节直到下一次调用才生效。如果返回的长度少于n的长度，
  
  func (b *Reader) Read(p []byte) (n int, err error)
    Read reads data into p. It returns the number of bytes read into p. It calls Read at most once on the underlying Reader, hence n may be less than len(p). At EOF, the count will be zero and err will be io.EOF.
    读取数据入P， 返回写入P的字节数。只调用一次Reader，因此n可以是小于P的长度，读取结束前，长度是0,错误是io.EOF
  
  func (b *Reader) ReadByte() (c byte, err error)
    ReadByte reads and returns a single byte. If no byte is available, returns an error.
    返回单个字节，如果没有字节符合返回错误
  
  func (b *Reader) ReadBytes(delim byte) (line []byte, err error)
    ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.
    读取输入的字节，直到第一次遇到delim，返回包含数据和分隔符的切片。如果函数在遇到分隔符之前出现错误，它返回读取到错误之前的数据和错误（错误经常是io.EOF）。ReadBytes只有在数据没有遇到分隔符但却已经读到结束的时候会返回err!=nil。对于简单的运用，Scanner 可能更适合
  
  func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)
    ReadLine is a low-level line-reading primitive. Most callers should use ReadBytes('\n') or ReadString('\n') instead or use a Scanner.
    ReadLine是一个低级的行读取方式。更多的会使用ReadBytes('\n')或者 ReadString('\n') 替代 或者用Scanner
    ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both.
    ReadLine试图返回单行，不包含结束字节。如果缓冲区的行太长，isPrefix 设置返回行的开始。其余的行将会在调用的时候返回。isPrefix 在返回完所有的行后，会变成false。返回的缓冲区在下次调用ReadLine之前是有效的。ReadLine 要嘛返回非空的行要嘛返回错误，不会两个都同时返回
    The text returned from ReadLine does not include the line end ("\r\n" or "\n"). No indication or error is given if the input ends without a final line end.
    ReadLine 返回的文本不包含行结束的 ("\r\n" or "\n")。在最后一行结束之前是不会有任何迹象和错误的
    
  func (b *Reader) ReadRune() (r rune, size int, err error)
    ReadRune reads  single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1.
    ReadRune 读取utf8 格式的字符返回rune和rune的size。
  
  func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
    ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read call. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error ErrBufferFull if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use ReadBytes or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim.
    读取直到遇到分隔符delim，返回一个指向字节的缓冲区切片，下一次调用后失效。如果ReadSlice在遇到分隔符之前发生错误，将会返回缓冲区里的所有数据和错误，如果缓冲区满了，但是还没遇到分隔符就会有 缓冲区满的错误。因为ReadSlice 返回的数据会覆盖下一个IO操作，所以大部分的客户端用 ReadBytes 或 ReadString 替代。 ReadSlice 只会在行没有分隔符结束的情况下返回err != nil
  
  func (b *Reader) ReadString(delim byte) (line string, err error)
    ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient.
    ReadString读取直接遇到第一个分隔符。返回包含分隔符的字符串。如果ReadString在没有发现分隔符就遇到错误，返回发生错误之前读取的数据和错误。ReadSlice 只会在行没有分隔符结束的情况下返回err != nil。对于简单的运用，Scanner 更方便
  
  func (b *Reader) UnreadByte() error
    UnreadByte unreads the last byte. Only the most recently read byte can be unread.
  
  func (b *Reader) UnreadRune() error
    UnreadRune unreads the last rune. If the most recent read operation on the buffer was not a ReadRune, UnreadRune returns an error. (In this regard it is stricter than UnreadByte, which will unread the last byte from any read operation.)
    
  
  func (b *Reader) WriteTo(w io.Writer) (n int64, err error)
    WriteTo implements io.WriterTo.
    io.WriterTo的是实现
  
type Scanner
  type Scanner struct {
        // contains filtered or unexported fields
  }
  Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the Scan method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type SplitFunc; the default split function breaks the input into lines with line termination stripped. Split functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function.
  Scanner提供一个更方便的接口读取数据，像文件的新行分隔文本的行。继承Scan方法的使用tokens对文件单步调试调用，跳出tokens之间的字节。token的规格定义是一个SplitFunc类型的分割函数，默认的分割函数将输入的行中断。  分割函数在这个包的是一个文件的行，字节，UTF8字节和间隔符。客户端可以自定义函数来替代分割函数。
  Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the buffer. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use bufio.Reader instead.
  搜索在遇到结束符、第一个I/O错误、或者token大于缓冲区的大小。当一个搜索结束，读取者也许会离最后一个token任意远。程序在必须更多的控制错误处理或太大的tokens，或者连续的搜索，应该用 bufio.Reader代替

  func NewScanner(r io.Reader) *Scanner
    NewScanner returns a new Scanner to read from r. The split function defaults to ScanLines
    NewScanner 从r返回一个新的*Scanner。分割函数默认是ScanLines
    
  func (s *Scanner) Bytes() []byte
    Bytes returns the most recent token generated by a call to Scan. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation.
    Bytes 调用Scan的时候返回最近的token。底层数组指向的数据将会覆盖后来调用的Scan。它没有分配。
    
  func (s *Scanner) Err() error
    Err returns the first non-EOF error that was encountered by the Scanner.
    Err 在Scanner遇到第一个非结束符错误返回
    
  func (s *Scanner) Scan() bool
    Scan advances the Scanner to the next token, which will then be available through the Bytes or Text method. It returns false when the scan stops, either by reaching the end of the input or an error. After Scan returns false, the Err method will return any error that occurred during scanning, except that if it was io.EOF, Err will return nil.
    Scan 搜索下一个token， 通过一个字节或者文本方法。当然搜索停止、搜索到末尾、或遇到错误时返回false。当Scan 返回false。Err 方法将会返回在搜索期间遇到的任何错误除了io.EOF会返回nil。
    
  func (s *Scanner) Split(split SplitFunc)
    Split sets the split function for the Scanner. If called, it must be called before Scan. The default split function is ScanLines.
    Split 设置搜索的分割函数，如果有调用，必须在Scan之前调用，默认的分割函数是ScanLines
  
  func (s *Scanner) Text() string
    Text returns the most recent token generated by a call to Scan as a newly allocated string holding its bytes.
    Text 返回最近的token，在调用Scan重新分配字符串的时候。
  
type SplitFunc
  type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)
    SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the Reader has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, plus an error, if any. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, SplitFunc can return (0, nil) to signal the Scanner to read more data into the slice and try again with a longer slice starting at the same point in the input.
    SplitFunc是分割函数用于标记输入。参数是一个未处理的字串和一个flag、atEOF，记录不管读取者有没有给更多的数据。返回值是输入的字节的数量和下一个要用的token，如果有错误的话加上一个错误。
    If the returned error is non-nil, scanning stops and the error is returned to the client.

    The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text.

type Writer
    func NewWriter(wr io.Writer) *Writer
    func NewWriterSize(wr io.Writer, size int) *Writer
    func (b *Writer) Available() int
    func (b *Writer) Buffered() int
    func (b *Writer) Flush() error
    func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)
    func (b *Writer) Write(p []byte) (nn int, err error)
    func (b *Writer) WriteByte(c byte) error
    func (b *Writer) WriteRune(r rune) (size int, err error)
    func (b *Writer) WriteString(s string) (int, error)
